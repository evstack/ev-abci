package integration_test

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"

	"cosmossdk.io/math"
	"github.com/celestiaorg/tastora/framework/docker"
	"github.com/celestiaorg/tastora/framework/docker/container"
	"github.com/celestiaorg/tastora/framework/docker/cosmos"
	"github.com/celestiaorg/tastora/framework/docker/dataavailability"
	"github.com/celestiaorg/tastora/framework/testutil/sdkacc"
	"github.com/celestiaorg/tastora/framework/testutil/wait"
	"github.com/celestiaorg/tastora/framework/types"
	"github.com/cometbft/cometbft/crypto"
	cmtjson "github.com/cometbft/cometbft/libs/json"
	cmprivval "github.com/cometbft/cometbft/privval"
	sdk "github.com/cosmos/cosmos-sdk/types"
	"github.com/cosmos/cosmos-sdk/types/module/testutil"
	"github.com/cosmos/cosmos-sdk/x/auth"
	"github.com/cosmos/cosmos-sdk/x/bank"
	banktypes "github.com/cosmos/cosmos-sdk/x/bank/types"
	"github.com/moby/moby/client"
	"github.com/stretchr/testify/suite"
)

const (
	celestiaAppTag   = "v4.0.10"
	celestiaNodeTag  = "v0.23.5"
	celestiaAppRepo  = "ghcr.io/celestiaorg/celestia-app"
	celestiaNodeRepo = "ghcr.io/celestiaorg/celestia-node"
)

// DockerIntegrationTestSuite provides common functionality for integration tests using Docker
type DockerIntegrationTestSuite struct {
	suite.Suite

	dockerClient  *client.Client
	networkID     string
	celestiaChain *cosmos.Chain
	daNetwork     *dataavailability.Network
	evolveChain   *cosmos.Chain
	bridgeNode    *dataavailability.Node
}

// SetupTest initializes the Docker environment for each test
// celestia is deployed, a single bridge node and the rollkit chain.
func (s *DockerIntegrationTestSuite) SetupTest() {
	ctx := context.Background()
	s.dockerClient, s.networkID = docker.DockerSetup(s.T())

	s.celestiaChain = s.CreateCelestiaChain(ctx)
	s.T().Log("Celestia app chain started")

	s.bridgeNode = s.CreateDANetwork(ctx)
	s.T().Log("Bridge node started")

	s.evolveChain = s.CreateEvolveChain(ctx)
	s.T().Log("Evolve chain started")
}

// CreateCelestiaChain sets up a Celestia app chain for DA and stores it in the suite
func (s *DockerIntegrationTestSuite) CreateCelestiaChain(ctx context.Context) *cosmos.Chain {
	testEncCfg := testutil.MakeTestEncodingConfig(auth.AppModuleBasic{}, bank.AppModuleBasic{})
	celestia, err := cosmos.NewChainBuilder(s.T()).
		WithEncodingConfig(&testEncCfg).
		WithDockerClient(s.dockerClient).
		WithDockerNetworkID(s.networkID).
		WithImage(container.NewImage(celestiaAppRepo, celestiaAppTag, "10001:10001")).
		WithAdditionalStartArgs(
			"--force-no-bbr",
			"--grpc.enable",
			"--grpc.address", "0.0.0.0:9090",
			"--rpc.grpc_laddr=tcp://0.0.0.0:9098",
			"--timeout-commit", "1s",
			"--minimum-gas-prices", "0.000001utia",
		).
		WithNode(cosmos.NewChainNodeConfigBuilder().Build()).
		Build(ctx)

	s.Require().NoError(err)

	err = celestia.Start(ctx)
	s.Require().NoError(err)
	return celestia
}

// CreateDANetwork sets up the DA network with bridge and full nodes and stores it in the suite
func (s *DockerIntegrationTestSuite) CreateDANetwork(ctx context.Context) *dataavailability.Node {
	// Build DA network with bridge node
	daNetwork, err := dataavailability.NewNetworkBuilder(s.T()).
		WithDockerClient(s.dockerClient).
		WithDockerNetworkID(s.networkID).
		WithImage(container.NewImage(celestiaNodeRepo, celestiaNodeTag, "10001:10001")).
		WithNode(dataavailability.NewNodeBuilder().
			WithNodeType(types.BridgeNode).
			Build()).
		Build(ctx)
	s.Require().NoError(err)

	s.daNetwork = daNetwork

	genesisHash, err := getGenesisHash(ctx, s.celestiaChain)
	s.Require().NoError(err)

	bridgeNodes := daNetwork.GetNodesByType(types.BridgeNode)
	s.Require().NotEmpty(bridgeNodes, "no bridge nodes available")

	bridgeNode := bridgeNodes[0]

	chainID := s.celestiaChain.GetChainID()
	networkInfo, err := s.celestiaChain.GetNodes()[0].GetNetworkInfo(ctx)
	s.Require().NoError(err)
	celestiaNodeHostname := networkInfo.Internal.Hostname

	err = bridgeNode.Start(ctx,
		dataavailability.WithChainID(chainID),
		// my-key is the name of the keyring generated by the bridge node, we can fund this key so that we can submit blobs.
		dataavailability.WithAdditionalStartArguments("--p2p.network", chainID, "--core.ip", celestiaNodeHostname, "--rpc.addr", "0.0.0.0", "--keyring.keyname", "my-key"),
		dataavailability.WithEnvironmentVariables(map[string]string{
			"CELESTIA_CUSTOM": types.BuildCelestiaCustomEnvVar(chainID, genesisHash, ""),
			"P2P_NETWORK":     chainID,
		}),
	)
	s.Require().NoError(err)

	// Fund the bridge node DA wallet to enable blob submission
	s.fundBridgeNodeWallet(ctx, bridgeNode)

	return bridgeNode
}

// CreateEvolveChain sets up the rollkit chain connected to the DA network and returns it
func (s *DockerIntegrationTestSuite) CreateEvolveChain(ctx context.Context) *cosmos.Chain {
	// Get DA connection details
	authToken, err := s.bridgeNode.GetAuthToken()
	s.Require().NoError(err)

	bridgeNetworkInfo, err := s.bridgeNode.GetNetworkInfo(ctx)
	s.Require().NoError(err)
	bridgeRPCAddress := bridgeNetworkInfo.Internal.RPCAddress()

	daAddress := fmt.Sprintf("http://%s", bridgeRPCAddress)

	celestiaHeight, err := s.celestiaChain.Height(ctx)
	s.Require().NoError(err)
	daStartHeight := fmt.Sprintf("%d", celestiaHeight)

	// bank and auth modules required to deal with bank send tx's
	testEncCfg := testutil.MakeTestEncodingConfig(auth.AppModuleBasic{}, bank.AppModuleBasic{})
	// Create chain with only the aggregator node initially
	evolveChain, err := cosmos.NewChainBuilder(s.T()).
		WithEncodingConfig(&testEncCfg).
		WithImage(getEvolveAppContainer()).
		WithDenom("stake").
		WithDockerClient(s.dockerClient).
		WithName("evolve").
		WithDockerNetworkID(s.networkID).
		WithChainID("evolve-test").
		WithBech32Prefix("gm").
		WithBinaryName("gmd").
		// explicitly set 0 gas so that we can make exact assertions when sending balances.
		WithGasPrices(fmt.Sprintf("0.00%s", "stake")).
		WithAdditionalExposedPorts("7331").
		WithNodes(
			cosmos.NewChainNodeConfigBuilder().
				// Create aggregator node with rollkit-specific start arguments
				WithAdditionalStartArgs(
					"--evnode.node.aggregator",
					"--evnode.signer.passphrase", "12345678",
					"--evnode.da.address", daAddress,
					"--evnode.da.gas_price", "0.000001",
					"--evnode.da.auth_token", authToken,
					"--evnode.rpc.address", "0.0.0.0:7331",
					"--evnode.da.namespace", "ev-header",
					"--evnode.da.data_namespace", "ev-data",
					"--evnode.da.start_height", daStartHeight,
					"--evnode.p2p.listen_address", "/ip4/0.0.0.0/tcp/36656",
					"--log_level", "*:info",
				).
				WithPostInit(addSingleSequencer).
				Build(),
		).
		Build(ctx)

	s.Require().NoError(err)

	// Start the aggregator node first so that we can query the p2p
	err = evolveChain.Start(ctx)
	s.Require().NoError(err)

	// wait for aggregator to produce just 1 block to ensure it's running
	s.T().Log("Waiting for aggregator to produce blocks...")
	s.Require().NoError(wait.ForBlocks(ctx, 1, evolveChain))

	// Get aggregator's network info to construct ev-node RPC address
	// Use External address since we're calling from the test host
	networkInfo, err := evolveChain.GetNode().GetNetworkInfo(ctx)
	s.Require().NoError(err)

	s.T().Logf("NetworkInfo - External: IP=%s, Hostname=%s", networkInfo.External.IP, networkInfo.External.Hostname)

	aggregatorPeer := s.GetNodeMultiAddr(ctx, networkInfo.External.Hostname+":"+networkInfo.External.Ports.EVNodeRPC)
	s.T().Logf("Aggregator peer: %s", aggregatorPeer)

	s.T().Logf("Adding first follower node...")
	s.addFollowerNode(ctx, evolveChain, daAddress, authToken, daStartHeight, aggregatorPeer)

	// wait for first follower to sync before adding second
	s.T().Logf("Waiting for first follower to sync...")
	s.waitForFollowerSync(ctx, evolveChain)

	//s.T().Logf("Adding second follower node...")
	//s.addFollowerNode(ctx, evolveChain, daAddress, authToken, daStartHeight, aggregatorPeer)
	//
	//wait for all follower nodes to sync with aggregator
	//s.T().Logf("Waiting for all follower nodes to sync...")
	//s.waitForFollowerSync(ctx, evolveChain)

	return evolveChain
}

// GetNodeMultiAddr queries the ev-node RPC to get the actual p2p multiaddr
// Returns the multiaddr in the format: /ip4/{IP}/tcp/36656/p2p/{PEER_ID}
func (s *DockerIntegrationTestSuite) GetNodeMultiAddr(ctx context.Context, rpcAddress string) string {
	// The ev-node RPC uses Connect protocol (HTTP/1.1 compatible)
	// Make HTTP POST to the Connect endpoint
	rpcURL := fmt.Sprintf("http://%s/evnode.v1.P2PService/GetNetInfo", rpcAddress)
	s.T().Logf("Calling RPC URL: %s", rpcURL)

	req, err := http.NewRequestWithContext(ctx, "POST", rpcURL, bytes.NewReader([]byte("{}")))
	s.Require().NoError(err)

	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{Timeout: 10 * time.Second}
	resp, err := client.Do(req)
	s.Require().NoError(err)
	defer resp.Body.Close()

	s.T().Logf("Response status: %d", resp.StatusCode)

	// Read response body for logging
	bodyBytes, err := io.ReadAll(resp.Body)
	s.Require().NoError(err)
	s.T().Logf("Response body: %s", string(bodyBytes))

	s.Require().Equal(200, resp.StatusCode, "unexpected status code from RPC")

	var response struct {
		NetInfo struct {
			ID              string   `json:"id"`
			ListenAddresses []string `json:"listenAddresses"`
		} `json:"netInfo"`
	}

	err = json.Unmarshal(bodyBytes, &response)
	s.Require().NoError(err)
	s.T().Logf("Parsed response - ID: %s, ListenAddresses: %v", response.NetInfo.ID, response.NetInfo.ListenAddresses)
	s.Require().NotEmpty(response.NetInfo.ListenAddresses, "no listen addresses returned")

	// Find the non-localhost address
	var multiAddr string
	for _, addr := range response.NetInfo.ListenAddresses {
		if !contains(addr, "127.0.0.1") {
			multiAddr = addr
			break
		}
	}

	s.Require().NotEmpty(multiAddr, "no non-localhost listen address found")
	s.T().Logf("Selected multiaddr: %s", multiAddr)
	return multiAddr
}

func contains(s, substr string) bool {
	return len(s) >= len(substr) && func() bool {
		for i := 0; i <= len(s)-len(substr); i++ {
			if s[i:i+len(substr)] == substr {
				return true
			}
		}
		return false
	}()
}

// addFollowerNode adds a follower node to the evolve chain.
func (s *DockerIntegrationTestSuite) addFollowerNode(ctx context.Context, evolveChain *cosmos.Chain, daAddress, authToken, daStartHeight, aggregatorPeer string) {
	err := evolveChain.AddNode(ctx, cosmos.NewChainNodeConfigBuilder().
		WithAdditionalStartArgs(
			"--evnode.da.address", daAddress,
			"--evnode.da.gas_price", "0.000001",
			"--evnode.da.auth_token", authToken,
			"--evnode.rpc.address", "0.0.0.0:7331",
			"--evnode.da.namespace", "ev-header",
			"--evnode.da.data_namespace", "ev-data",
			"--evnode.da.start_height", daStartHeight,
			"--evnode.p2p.listen_address", "/ip4/0.0.0.0/tcp/36656",
			"--evnode.p2p.peers", aggregatorPeer,
			"--log_level", "*:debug",
		).
		Build())
	s.Require().NoError(err)
}

// waitForFollowerSync waits for all follower nodes to be within acceptable delta of aggregator
func (s *DockerIntegrationTestSuite) waitForFollowerSync(ctx context.Context, evolveChain *cosmos.Chain) {
	nodes := evolveChain.GetNodes()
	if len(nodes) <= 1 {
		return
	}

	syncCtx, cancel := context.WithTimeout(ctx, 5*time.Minute)
	defer cancel()

	ticker := time.NewTicker(2 * time.Second)
	defer ticker.Stop()

	const maxAcceptableDelta = 5 // followers can be up to 5 blocks behind

	for {
		select {
		case <-syncCtx.Done():
			s.Require().FailNow("timeout waiting for followers to sync")
		case <-ticker.C:
			aggHeight, err := nodes[0].(*cosmos.ChainNode).Height(syncCtx)
			if err != nil {
				s.T().Logf("Failed to get aggregator height: %v", err)
				continue
			}

			allInSync := true
			for i := 1; i < len(nodes); i++ {
				followerHeight, err := nodes[i].(*cosmos.ChainNode).Height(syncCtx)
				if err != nil {
					s.T().Logf("Failed to get follower %d height: %v", i, err)
					allInSync = false
					continue
				}

				delta := aggHeight - followerHeight
				s.T().Logf("Follower %d: height=%d, aggregator=%d, delta=%d", i, followerHeight, aggHeight, delta)

				if delta > maxAcceptableDelta {
					allInSync = false
				}
			}

			if allInSync {
				s.T().Logf("All %d follower nodes are now in sync (within %d blocks of aggregator)", len(nodes)-1, maxAcceptableDelta)
				return
			}
		}
	}
}

// getGenesisHash retrieves the genesis hash from the celestia chain
func getGenesisHash(ctx context.Context, chain types.Chain) (string, error) {
	node := chain.GetNodes()[0]
	c, err := node.GetRPCClient()
	if err != nil {
		return "", fmt.Errorf("failed to get node client: %w", err)
	}

	first := int64(1)
	block, err := c.Block(ctx, &first)
	if err != nil {
		return "", fmt.Errorf("failed to get block: %w", err)
	}

	genesisHash := block.Block.Header.Hash().String()
	if genesisHash == "" {
		return "", fmt.Errorf("genesis hash is empty")
	}

	return genesisHash, nil
}

// copyWalletKeyToNode ensures the given wallet's private key is present in the target node's keyring.
// It exports the key from the aggregator node (index 0) and imports it into the target node.
//func (s *DockerIntegrationTestSuite) copyWalletKeyToNode(ctx context.Context, chain *cosmos.Chain, wallet *types.Wallet, targetNode *cosmos.ChainNode) error {
//	// Get source (aggregator) keyring
//	srcNode, ok := chain.GetNodes()[0].(*cosmos.ChainNode)
//	if !ok {
//		return fmt.Errorf("aggregator node is not a cosmos.ChainNode")
//	}
//	srcKr, err := srcNode.GetKeyring()
//	if err != nil {
//		return fmt.Errorf("failed to get source keyring: %w", err)
//	}
//
//	// Get target keyring
//	dstKr, err := targetNode.GetKeyring()
//	if err != nil {
//		return fmt.Errorf("failed to get target keyring: %w", err)
//	}
//
//	keyName := wallet.GetKeyName()
//
//	// Try to lookup on destination first; if present, no-op
//	if _, err := dstKr.Key(keyName); err == nil {
//		return nil
//	}
//
//	// Export from source and import into destination (empty passphrase for test backend)
//	armored, err := srcKr.ExportPrivKeyArmor(keyName, "")
//	if err != nil {
//		return fmt.Errorf("failed to export key %q from source: %w", keyName, err)
//	}
//
//	if err := dstKr.ImportPrivKey(keyName, armored, ""); err != nil {
//		return fmt.Errorf("failed to import key %q into target: %w", keyName, err)
//	}
//	return nil
//}

// sendFunds sends funds from one wallet to another using bank transfer
func (s *DockerIntegrationTestSuite) sendFunds(ctx context.Context, chain *cosmos.Chain, fromWallet, toWallet *types.Wallet, amount sdk.Coins, nodeIdx int) error {
	fromAddress, err := sdkacc.AddressFromWallet(fromWallet)
	if err != nil {
		return fmt.Errorf("failed to get sender address: %w", err)
	}

	toAddress, err := sdkacc.AddressFromWallet(toWallet)
	if err != nil {
		return fmt.Errorf("failed to get destination address: %w", err)
	}

	chainNode := chain.GetNodes()[nodeIdx]
	cosmosChainNode, ok := chainNode.(*cosmos.ChainNode)
	if !ok {
		return fmt.Errorf("chainNode is not a cosmos.ChainNode")
	}

	// Ensure the fromWallet key exists on the target node's keyring
	// Wallets are created on chain.GetNode() (index 0). When broadcasting via a different
	// node, copy the private key into that node's keyring for signing.
	//if nodeIdx != 0 {
	//	if err := s.copyWalletKeyToNode(ctx, chain, fromWallet, cosmosChainNode); err != nil {
	//		return fmt.Errorf("failed to copy wallet key to target node: %w", err)
	//	}
	//
	//	// Ensure the target node is in sync with the aggregator so account state exists
	//	// on this node before we attempt to sign and broadcast.
	//	syncCtx, cancel := context.WithTimeout(ctx, 5*time.Minute)
	//	defer cancel()
	//	s.T().Logf("Waiting for target node to be in sync...")
	//	if err := wait.ForInSync(syncCtx, chain, cosmosChainNode); err != nil {
	//		return fmt.Errorf("target node not yet in sync for broadcast: %w", err)
	//	}
	//}
	broadcaster := cosmos.NewBroadcasterForNode(chain, cosmosChainNode)

	msg := banktypes.NewMsgSend(fromAddress, toAddress, amount)
	resp, err := broadcaster.BroadcastMessages(ctx, fromWallet, msg)
	if err != nil {
		return fmt.Errorf("failed to broadcast transaction: %w", err)
	}

	if resp.Code != 0 {
		return fmt.Errorf("transaction failed with code %d: %s", resp.Code, resp.RawLog)
	}

	return nil
}

// addSingleSequencer modifies the genesis file to ensure single sequencer setup
func addSingleSequencer(ctx context.Context, node *cosmos.ChainNode) error {
	genesisBz, err := node.ReadFile(ctx, "config/genesis.json")
	if err != nil {
		return fmt.Errorf("failed to read genesis.json: %w", err)
	}

	pubKey, err := getPubKey(ctx, node)
	if err != nil {
		return fmt.Errorf("failed to get pubkey: %w", err)
	}

	var genDoc map[string]interface{}
	if err := json.Unmarshal(genesisBz, &genDoc); err != nil {
		return fmt.Errorf("failed to parse genesis.json: %w", err)
	}

	// set consensus validators to only include the first validator
	consensus, ok := genDoc["consensus"].(map[string]interface{})
	if !ok {
		return fmt.Errorf("genesis.json does not contain a valid 'consensus' object")
	}
	consensus["validators"] = []map[string]interface{}{
		{
			"name":    "Rollkit Sequencer",
			"address": pubKey.Address(),
			"pub_key": map[string]interface{}{
				"type":  "tendermint/PubKeyEd25519",
				"value": pubKey.Bytes(),
			},
			"power": "5",
		},
	}

	updatedGenesis, err := json.MarshalIndent(genDoc, "", "  ")
	if err != nil {
		return fmt.Errorf("failed to marshal genesis: %w", err)
	}

	err = node.WriteFile(ctx, "config/genesis.json", updatedGenesis)
	if err != nil {
		return fmt.Errorf("failed to write genesis.json: %w", err)
	}

	return nil
}

// getPubKey returns the validator public key
func getPubKey(ctx context.Context, chainNode *cosmos.ChainNode) (crypto.PubKey, error) {
	keyJSONBytes, err := chainNode.ReadFile(ctx, "config/priv_validator_key.json")
	if err != nil {
		return nil, err
	}
	var pvKey cmprivval.FilePVKey
	if err = cmtjson.Unmarshal(keyJSONBytes, &pvKey); err != nil {
		return nil, fmt.Errorf("failed to unmarshal priv_validator_key.json: %w", err)
	}
	return pvKey.PubKey, nil
}

// fundBridgeNodeWallet funds the bridge node's DA wallet for blob submission
func (s *DockerIntegrationTestSuite) fundBridgeNodeWallet(ctx context.Context, bridgeNode *dataavailability.Node) {
	// hack to get around global, need to set the address prefix before use.
	sdk.GetConfig().SetBech32PrefixForAccount("celestia", "celestiapub")

	s.T().Log("Funding bridge node DA wallet...")
	fundingWallet := s.celestiaChain.GetFaucetWallet()

	// Get the bridge node's wallet
	bridgeWallet, err := bridgeNode.GetWallet()
	s.Require().NoError(err)

	// fund the bridge node wallet
	daFundingAmount := sdk.NewCoins(sdk.NewCoin("utia", math.NewInt(10_000_000)))
	err = s.sendFunds(ctx, s.celestiaChain, fundingWallet, bridgeWallet, daFundingAmount, 0)
	s.Require().NoError(err)
}
